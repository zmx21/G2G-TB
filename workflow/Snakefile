from distutils.util import strtobool
import pandas as pd

configfile: "../config/config.yaml"
Sample_File = pd.read_csv(config["Metdata"], sep='\t')
Mtb_IDS = Sample_File["G_NUMBER"].tolist()

if config["Analysis_Type"] == "G2G":
  rule all:
    input:
      results=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+'/'+config["tool"]+"/PC_"+str(config["N_PC"])+"_pPC_"+str(config["N_pPC"])+"/Stratified_"+config["Stratified"]+"/G2G_results.rds"
      
elif config["Analysis_Type"] == "TB_score" or config["Analysis_Type"] == "Xray_score":
  rule all:
    input:
      results=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+"/"+config["tool"]+"/PC_"+str(config["N_PC"])+"_pPC_"+str(config["N_pPC"])+"/Stratified_"+config["Stratified"]+"/"+config["Analysis_Type"]+"_int_results.rds"


rule process_mtb_VCF:
  input:
    VCF_file=config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.all.pos.vcf.gz'
  output:
    homo_snps=config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.var.homo.SNPs.vcf.gz',
    homo_het_snps=config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.var.homo.het.SNPs.vcf.gz',
    missing_snps_homo=config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.homo.missing',
    missing_snps_homo_het=config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.homo.het.missing',
    reads=config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.reads.gz'
  threads:
    1
  conda:
    '../envs/Bcftools_Bedtools.yaml'
  shell:
    '''
      bcftools filter -i 'GT=="1/1"' -O z -o {output.homo_snps} {input.VCF_file} #Keep both homo calls only.
      bcftools index -t  {output.homo_snps}
            
      bcftools filter -i 'GT=="1/1" || GT=="0/1" || GT=="1/0"' -O z -o {output.homo_het_snps} {input.VCF_file} #Keep both homo and mixed calls.  
      bcftools index -t  {output.homo_het_snps}

      bcftools filter -i 'GT=="./." || GT=="0/1" || GT=="1/0"' {input.VCF_file} | bcftools query -f '%POS %REF %ALT\n' > {output.missing_snps_homo} 

      bcftools filter -i 'GT=="./."' {input.VCF_file} | bcftools query -f '%POS %REF %ALT\n' > {output.missing_snps_homo_het} 
      bcftools query -f '%POS %REF %ALT [%AD] [%RD] [%SDP] [%DP] [%RBQ] [%ABQ] [%RDF] [%RDR] [%ADF] [%ADR] [%FREQ] [%GT] [%GQ]\n' {input.VCF_file} | pigz --fast > {output.reads}
    '''

rule merge_mtb_VCF:
  input:    
    homo_snps=expand(config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.var.homo.SNPs.vcf.gz',id=Mtb_IDS),
    homo_het_snps=expand(config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.var.homo.het.SNPs.vcf.gz',id=Mtb_IDS),
    locus_to_excl=config["MTB_DATA"]+'Locus_to_exclude_Mtb_Parsed.txt'
  output:
    homo_snps=config["MTB_DATA"]+'merged/merged.var.homo.SNPs.vcf',
    homo_het_snps=config["MTB_DATA"]+'merged/merged.var.homo.het.SNPs.vcf',
    homo_dosage=config["MTB_DATA"]+'merged/merged.var.homo.SNPs.vcf.dosage',
    homo_het_dosage=config["MTB_DATA"]+'merged/merged.var.homo.het.SNPs.vcf.dosage'
  threads:
    50
  conda:
    '../envs/Bcftools_Bedtools.yaml'
  shell:
    '''
      bcftools merge --threads {threads} -0 -m none {input.homo_snps} -O v -o {output.homo_snps}.tmp
      bedtools subtract -header -A -a {output.homo_snps}.tmp -b {input.locus_to_excl} > {output.homo_snps}
      bgzip -c {output.homo_snps} > {output.homo_snps}.gz
      bcftools index -t {output.homo_snps}.gz
      rm {output.homo_snps}.tmp
      bcftools +dosage {output.homo_snps}.gz > {output.homo_snps}.dosage
      
      bcftools merge --threads {threads} -0 -m none {input.homo_het_snps} -O v -o {output.homo_het_snps}.tmp
      bedtools subtract -header -A -a {output.homo_het_snps}.tmp -b {input.locus_to_excl} > {output.homo_het_snps}
      bgzip -c {output.homo_het_snps} > {output.homo_het_snps}.gz
      bcftools index -t {output.homo_het_snps}.gz
      rm {output.homo_het_snps}.tmp
      bcftools +dosage {output.homo_het_snps}.gz > {output.homo_het_snps}.dosage
    '''
    
    
def get_missing_path(wildcards):
  # return missing file where het calls are treated as NA, along with missing positions
  if strtobool(config["Homo_Only"]):
      return expand(config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.homo.missing',id=Mtb_IDS)
  # return missing file where only missing positions are treated as NA
  else:
      return expand(config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.homo.het.missing',id=Mtb_IDS)

rule get_missing_pos:
  input:
      gff='../data/Mtb/Mtb_VCF_files/GCF_000195955.2.gff',
      VCF_Files=expand(config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{id}.all.pos.vcf.gz',id=Mtb_IDS),
      missing_files=get_missing_path
  params:
      out_dir=config["SCRATCH_DIR"]+'Mtb_Coverage/HomoOnly_'+config["Homo_Only"]+'/'
  output:
      missing_mat=config["SCRATCH_DIR"]+'Mtb_Coverage/HomoOnly_'+config["Homo_Only"]+'/missing_mat.rds'
  threads: 
    50
  conda:
    '../envs/Mtb_Processing.yaml'
  shell:
      "Rscript ./scripts/GetCoverage.R {input.VCF_Files} {input.missing_files} {input.gff} {params.out_dir} {threads}"

def get_snp_path(wildcards):
  # return homo SNPs only
  if strtobool(config["Homo_Only"]):
      return config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{}.var.homo.SNPs.vcf.gz'.format(wildcards["id"])
  # return both homo and het snps
  else:
      return config["MTB_DATA"]+'Mtb_VCF_files/full_allpos/{}.var.homo.het.SNPs.vcf.gz'.format(wildcards["id"])

rule make_AA_Tbl:
  input:
    snps=get_snp_path,
    locus_to_excl=config["MTB_DATA"]+'Locus_to_exclude_Mtb_Parsed.txt'
  params:
    snpEff='../software/snpEff/SnpSift.jar'
  output:
    AA_variant=config["SCRATCH_DIR"]+'AA_HomoOnly_'+config["Homo_Only"]+'/{id}.txt',
    Syn_variant=config["SCRATCH_DIR"]+'Syn_HomoOnly_'+config["Homo_Only"]+'/{id}.txt'
  threads: 1
  conda:
    '../envs/Mtb_Processing.yaml'
  shell:
    '''
        Rscript ./scripts/MakeAATable.R {input.snps} {input.locus_to_excl} {params.snpEff} {wildcards.id} {output.AA_variant} {output.Syn_variant}
    '''

rule make_AA_Matrix:
  input:
    missing_mat=config["SCRATCH_DIR"]+'Mtb_Coverage/HomoOnly_'+config["Homo_Only"]+'/missing_mat.rds',
    phylo_snps=config["MTB_DATA"]+'PositionsPhylogeneticSNPs_20171004.txt',
    sift_path=config["MTB_DATA"]+"SIFT/GCA_000195955.2.22/Chromosome.gz",
    AA_variant=expand(config["SCRATCH_DIR"]+'AA_HomoOnly_'+config["Homo_Only"]+'/{id}.txt',id=Mtb_IDS),
    Syn_variant=expand(config["SCRATCH_DIR"]+'Syn_HomoOnly_'+config["Homo_Only"]+'/{id}.txt',id=Mtb_IDS),
    del_tbl=config["Del_tbl"]
  params:
    IS_SIFT=bool(strtobool(config["SIFT"])),
    IS_Burden=bool(strtobool(config["Burden"])),
    IS_Deletion=bool(strtobool(config["Deletion"])),
    Het_Thresh=config["Het_Thresh"],
    metadata=config["Metdata"]
  output:
    Mtb_Var_Tbl=config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+"/Mtb_Var_Tbl.rds"
  threads: 
    50
  conda:
    '../envs/Mtb_Processing.yaml'
  shell:
    "Rscript ./scripts/MakeVariantMatrix.R {input.AA_variant} {input.Syn_variant} {input.missing_mat} {input.phylo_snps} {input.del_tbl} {input.sift_path} {params.IS_SIFT} {params.IS_Burden} {params.IS_Deletion} {output.Mtb_Var_Tbl} {params.metadata} {params.Het_Thresh} {threads}"
    
def merged_dosage_path(wildcards):
  # return homo SNPs only
  if strtobool(config["Homo_Only"]):
      return config["MTB_DATA"]+'merged/merged.var.homo.SNPs.vcf.dosage'
  # return both homo and het snps
  else:
      return config["MTB_DATA"]+'merged/merged.var.homo.het.SNPs.vcf.dosage'

rule setup_host:
  input:
    host_bfile=config["host_bfile"]+'.bed',
    host_hla_vcf=config["HLA_Data"]+'chr6.dose.vcf.gz'
  params:
    Out_DIR=config["SCRATCH_DIR"],
    excl_region='../data/exclusion_regions_hg19.txt',
    metadata=config["Metdata"]
  output:
    config["SCRATCH_DIR"]+"Host/TB_DAR_GWAS_PCA.eigenvec"
  threads:
    1
  conda:
    '../envs/Host_Processing.yaml'
  shell:
    '''
      Rscript ./scripts/SetUpHost.R {params.metadata} {input.host_bfile} {input.host_hla_vcf} {params.Out_DIR} {params.excl_region} {threads}
    '''
    
rule setup_G2G:
  input:
    Mtb_Var_Tbl=config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+"/Mtb_Var_Tbl.rds",
    merged_dosage=merged_dosage_path,
    host_bfile=config["host_bfile"]+'.bed',
    host_pc=config["SCRATCH_DIR"]+"Host/TB_DAR_GWAS_PCA.eigenvec"
  params:
    metadata=config["Metdata"],
    Phylo_Tree_Path=config["MTB_DATA"]+'RAxML_bestTree.Sinergia_final_dataset_human_bac_genome_available_rerooted.nwk',
    Out_DIR=config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"]),
    Host_MAF=config["Host_MAF"],
    Pathogen_MAC_pPCA=config["Pathogen_MAC_pPCA"],
    Pathogen_MAC_AA_Lineage = config["Pathogen_MAC_AA_Lineage"],
    Pathogen_MAC_AA=config["Pathogen_MAC_AA"],
    Pathogen_Missing=config["Pathogen_Missing"],
    Host_Files=config["SCRATCH_DIR"]+"Host/"
  output:
    config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+"/G2G_Obj.rds"
  threads:
    50
  conda:
    '../envs/Host_Processing.yaml'
  shell:
    "Rscript ./scripts/SetUpG2G.R {params.Out_DIR} {params.metadata} {input.host_pc} {input.Mtb_Var_Tbl} {params.Phylo_Tree_Path} {input.merged_dosage} {params.Host_MAF} {params.Pathogen_MAC_pPCA} {params.Pathogen_MAC_AA_Lineage} {params.Pathogen_MAC_AA} {params.Pathogen_Missing} {input.host_bfile} {params.Host_Files} {threads}"

if config["Analysis_Type"] == "G2G":
  rule run_G2G:
    input:
      g2g_obj=config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+"/G2G_Obj.rds"
    params:
      tool=config["tool"],
      N_PC=config["N_PC"],
      N_pPC=config["N_pPC"],
      covars_to_incl=config["Covars_to_incl"],
      stratified=config["Stratified"],
      homo_only=config["Homo_Only"],
      out_dir=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])
    output:
      results=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+'/'+config["tool"]+"/PC_"+str(config["N_PC"])+"_pPC_"+str(config["N_pPC"])+"/Stratified_"+config["Stratified"]+"/G2G_results.rds"
    threads:
      110
    conda:
      '../envs/G2G.yaml'
    shell:
      " Rscript ./scripts/RunG2G.R {input.g2g_obj} {params.out_dir} {params.tool} {params.N_PC} {params.N_pPC} {params.covars_to_incl} {params.stratified} {params.homo_only} {threads}"
    
elif config["Analysis_Type"] == "TB_score" or config["Analysis_Type"] == "Xray_score":
  rule run_interaction:
    input:
      g2g_obj=config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"/G2G_Obj.rds"
    params:
      tool=config["tool"],
      N_PC=config["N_PC"],
      N_pPC=config["N_pPC"],
      covars_to_incl=config["Covars_to_incl"],
      stratified=config["Stratified"],
      homo_only=config["Homo_Only"],
      pheno=config["Analysis_Type"],
      out_dir=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])
    output:
      results=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"_HetThresh_"+str(config["Het_Thresh"])+"/"+config["tool"]+"/PC_"+str(config["N_PC"])+"_pPC_"+str(config["N_pPC"])+"/Stratified_"+config["Stratified"]+"/"+config["Analysis_Type"]+"_int_results.rds"
    threads:
      110
    conda:
      '../envs/G2G.yaml'
    shell:
      "Rscript ./scripts/RunInteraction.R {input.g2g_obj} {params.out_dir} {params.tool} {params.N_PC} {params.N_pPC} {params.covars_to_incl} {params.stratified} {params.homo_only} {params.pheno} {threads}"
else:
    print('Invalid Arugment: Analysis_Type')
    sys.exit()
    
rule run_PASCAL:
  input:
    res_obj=config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"/"+config["tool"]+"/PC_"+str(config["N_PC"])+"_pPC_"+str(config["N_pPC"])+"/"+config["Analysis_Type"]+"_results.rds",
    bim_1KG=config["PASCAL_path"]+"/resources/1kg_AFR/misc/AFR.bim"
  params:
    scratch_dir=config["SCRATCH_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]
  output:
    config["RESULTS_DIR"]+"Burden_"+config["Burden"]+"_SIFT_"+config["SIFT"]+"_Del_"+config["Deletion"]+"_HomoOnly_"+config["Homo_Only"]+"/"+config["tool"]+"/PC_"+str(config["N_PC"])+"_pPC_"+str(config["N_pPC"])+"/PASCAL_"+config["Analysis_Type"]+"_results.rds"
  threads:
      1
  shell:
      "Rscript ./scripts/RunPASCAL.R {input.res_obj} {input.bim_1KG} {params.scratch_dir} {params.output}"
      
